<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class Asciidoctor::Lexer - asciidoctor 0.0.9</title>

<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../index.html">Home</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/asciidoctor/lexer.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    <nav id="sections-section" class="section">
  <h3 class="section-header">Sections</h3>
  <ul class="link-list">
    
      <li><a href="#5Buntitled-5D"></a></li>
    
      <li><a href="#Public">Public</a></li>
    
      <li><a href="#Internal">Internal</a></li>
    
  </ul>
</nav>

    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link">Object
  
</nav>

    <!-- Included Modules -->
<nav id="includes-section" class="section">
  <h3 class="section-header">Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="../Asciidoctor.html">Asciidoctor</a>
  
  
  </ul>
</nav>

    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li><a href="#method-c-catalog_callouts">::catalog_callouts</a>
    
    <li><a href="#method-c-catalog_inline_anchors">::catalog_inline_anchors</a>
    
    <li><a href="#method-c-delimited_block-3F">::delimited_block?</a>
    
    <li><a href="#method-c-grab_lines_for_list_item">::grab_lines_for_list_item</a>
    
    <li><a href="#method-c-initialize_section">::initialize_section</a>
    
    <li><a href="#method-c-is_next_line_section-3F">::is_next_line_section?</a>
    
    <li><a href="#method-c-is_section_title-3F">::is_section_title?</a>
    
    <li><a href="#method-c-is_sibling_list_item-3F">::is_sibling_list_item?</a>
    
    <li><a href="#method-c-is_single_line_section_title-3F">::is_single_line_section_title?</a>
    
    <li><a href="#method-c-is_two_line_section_title-3F">::is_two_line_section_title?</a>
    
    <li><a href="#method-c-new">::new</a>
    
    <li><a href="#method-c-next_block">::next_block</a>
    
    <li><a href="#method-c-next_labeled_list">::next_labeled_list</a>
    
    <li><a href="#method-c-next_list_item">::next_list_item</a>
    
    <li><a href="#method-c-next_outline_list">::next_outline_list</a>
    
    <li><a href="#method-c-next_section">::next_section</a>
    
    <li><a href="#method-c-next_table">::next_table</a>
    
    <li><a href="#method-c-parse">::parse</a>
    
    <li><a href="#method-c-parse_block_metadata_line">::parse_block_metadata_line</a>
    
    <li><a href="#method-c-parse_block_metadata_lines">::parse_block_metadata_lines</a>
    
    <li><a href="#method-c-parse_cell_spec">::parse_cell_spec</a>
    
    <li><a href="#method-c-parse_col_specs">::parse_col_specs</a>
    
    <li><a href="#method-c-parse_header_metadata">::parse_header_metadata</a>
    
    <li><a href="#method-c-parse_section_title">::parse_section_title</a>
    
    <li><a href="#method-c-resolve_list_marker">::resolve_list_marker</a>
    
    <li><a href="#method-c-resolve_ordered_list_marker">::resolve_ordered_list_marker</a>
    
    <li><a href="#method-c-roman_numeral_to_int">::roman_numeral_to_int</a>
    
    <li><a href="#method-c-section_level">::section_level</a>
    
    <li><a href="#method-c-single_line_section_level">::single_line_section_level</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    
    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../Asciidoctor.html">Asciidoctor</a>
  
    <li><a href="../Asciidoctor/AbstractBlock.html">Asciidoctor::AbstractBlock</a>
  
    <li><a href="../Asciidoctor/AbstractNode.html">Asciidoctor::AbstractNode</a>
  
    <li><a href="../Asciidoctor/AttributeList.html">Asciidoctor::AttributeList</a>
  
    <li><a href="../Asciidoctor/BaseTemplate.html">Asciidoctor::BaseTemplate</a>
  
    <li><a href="../Asciidoctor/Block.html">Asciidoctor::Block</a>
  
    <li><a href="../Asciidoctor/Callouts.html">Asciidoctor::Callouts</a>
  
    <li><a href="../Asciidoctor/Cli.html">Asciidoctor::Cli</a>
  
    <li><a href="../Asciidoctor/Cli/Invoker.html">Asciidoctor::Cli::Invoker</a>
  
    <li><a href="../Asciidoctor/Cli/Options.html">Asciidoctor::Cli::Options</a>
  
    <li><a href="../Asciidoctor/DocBook45.html">Asciidoctor::DocBook45</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockAdmonitionTemplate.html">Asciidoctor::DocBook45::BlockAdmonitionTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockColistTemplate.html">Asciidoctor::DocBook45::BlockColistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockDlistTemplate.html">Asciidoctor::DocBook45::BlockDlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockExampleTemplate.html">Asciidoctor::DocBook45::BlockExampleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockFloatingTitleTemplate.html">Asciidoctor::DocBook45::BlockFloatingTitleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockImageTemplate.html">Asciidoctor::DocBook45::BlockImageTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockListingTemplate.html">Asciidoctor::DocBook45::BlockListingTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockLiteralTemplate.html">Asciidoctor::DocBook45::BlockLiteralTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockOlistTemplate.html">Asciidoctor::DocBook45::BlockOlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockOpenTemplate.html">Asciidoctor::DocBook45::BlockOpenTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockParagraphTemplate.html">Asciidoctor::DocBook45::BlockParagraphTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockPassTemplate.html">Asciidoctor::DocBook45::BlockPassTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockPreambleTemplate.html">Asciidoctor::DocBook45::BlockPreambleTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockQuoteTemplate.html">Asciidoctor::DocBook45::BlockQuoteTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockRulerTemplate.html">Asciidoctor::DocBook45::BlockRulerTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockSidebarTemplate.html">Asciidoctor::DocBook45::BlockSidebarTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockTableTemplate.html">Asciidoctor::DocBook45::BlockTableTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockUlistTemplate.html">Asciidoctor::DocBook45::BlockUlistTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/BlockVerseTemplate.html">Asciidoctor::DocBook45::BlockVerseTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/DocumentTemplate.html">Asciidoctor::DocBook45::DocumentTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/EmbeddedTemplate.html">Asciidoctor::DocBook45::EmbeddedTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineAnchorTemplate.html">Asciidoctor::DocBook45::InlineAnchorTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineBreakTemplate.html">Asciidoctor::DocBook45::InlineBreakTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineCalloutTemplate.html">Asciidoctor::DocBook45::InlineCalloutTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineImageTemplate.html">Asciidoctor::DocBook45::InlineImageTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/InlineQuotedTemplate.html">Asciidoctor::DocBook45::InlineQuotedTemplate</a>
  
    <li><a href="../Asciidoctor/DocBook45/SectionTemplate.html">Asciidoctor::DocBook45::SectionTemplate</a>
  
    <li><a href="../Asciidoctor/Document.html">Asciidoctor::Document</a>
  
    <li><a href="../Asciidoctor/HTML5.html">Asciidoctor::HTML5</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockAdmonitionTemplate.html">Asciidoctor::HTML5::BlockAdmonitionTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockColistTemplate.html">Asciidoctor::HTML5::BlockColistTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockDlistTemplate.html">Asciidoctor::HTML5::BlockDlistTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockExampleTemplate.html">Asciidoctor::HTML5::BlockExampleTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockFloatingTitleTemplate.html">Asciidoctor::HTML5::BlockFloatingTitleTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockImageTemplate.html">Asciidoctor::HTML5::BlockImageTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockListingTemplate.html">Asciidoctor::HTML5::BlockListingTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockLiteralTemplate.html">Asciidoctor::HTML5::BlockLiteralTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockOlistTemplate.html">Asciidoctor::HTML5::BlockOlistTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockOpenTemplate.html">Asciidoctor::HTML5::BlockOpenTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockParagraphTemplate.html">Asciidoctor::HTML5::BlockParagraphTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockPassTemplate.html">Asciidoctor::HTML5::BlockPassTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockPreambleTemplate.html">Asciidoctor::HTML5::BlockPreambleTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockQuoteTemplate.html">Asciidoctor::HTML5::BlockQuoteTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockRulerTemplate.html">Asciidoctor::HTML5::BlockRulerTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockSidebarTemplate.html">Asciidoctor::HTML5::BlockSidebarTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockTableTemplate.html">Asciidoctor::HTML5::BlockTableTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockUlistTemplate.html">Asciidoctor::HTML5::BlockUlistTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/BlockVerseTemplate.html">Asciidoctor::HTML5::BlockVerseTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/DocumentTemplate.html">Asciidoctor::HTML5::DocumentTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/EmbeddedTemplate.html">Asciidoctor::HTML5::EmbeddedTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineAnchorTemplate.html">Asciidoctor::HTML5::InlineAnchorTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineBreakTemplate.html">Asciidoctor::HTML5::InlineBreakTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineCalloutTemplate.html">Asciidoctor::HTML5::InlineCalloutTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineImageTemplate.html">Asciidoctor::HTML5::InlineImageTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/InlineQuotedTemplate.html">Asciidoctor::HTML5::InlineQuotedTemplate</a>
  
    <li><a href="../Asciidoctor/HTML5/SectionTemplate.html">Asciidoctor::HTML5::SectionTemplate</a>
  
    <li><a href="../Asciidoctor/Inline.html">Asciidoctor::Inline</a>
  
    <li><a href="../Asciidoctor/Lexer.html">Asciidoctor::Lexer</a>
  
    <li><a href="../Asciidoctor/ListItem.html">Asciidoctor::ListItem</a>
  
    <li><a href="../Asciidoctor/ProjectError.html">Asciidoctor::ProjectError</a>
  
    <li><a href="../Asciidoctor/Reader.html">Asciidoctor::Reader</a>
  
    <li><a href="../Asciidoctor/Renderer.html">Asciidoctor::Renderer</a>
  
    <li><a href="../Asciidoctor/SafeMode.html">Asciidoctor::SafeMode</a>
  
    <li><a href="../Asciidoctor/Section.html">Asciidoctor::Section</a>
  
    <li><a href="../Asciidoctor/Substituters.html">Asciidoctor::Substituters</a>
  
    <li><a href="../Asciidoctor/Table.html">Asciidoctor::Table</a>
  
    <li><a href="../Asciidoctor/Table/Cell.html">Asciidoctor::Table::Cell</a>
  
    <li><a href="../Asciidoctor/Table/Column.html">Asciidoctor::Table::Column</a>
  
    <li><a href="../Asciidoctor/Table/ParserContext.html">Asciidoctor::Table::ParserContext</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class Asciidoctor::Lexer</h1>

  <div id="description" class="description">
    
<p>Methods to parse lines of AsciiDoc into an object hierarchy representing
the structure of the document. All methods are class methods and should be
invoked from the <a href="Lexer.html">Lexer</a> class. The main entry point
is <a href="Lexer.html#method-c-next_block">::next_block</a>. No <a
href="Lexer.html">Lexer</a> instances shall be discovered running around.
(Any attempt to instantiate a <a href="Lexer.html">Lexer</a> will be
futile).</p>

<p>The object hierarchy created by the <a href="Lexer.html">Lexer</a> consists
of zero or more <a href="Section.html">Section</a> and <a
href="Block.html">Block</a> objects. <a href="Section.html">Section</a>
objects may be nested and a <a href="Section.html">Section</a> object
contains zero or more <a href="Block.html">Block</a> objects. <a
href="Block.html">Block</a> objects may be nested, but may only contain
other <a href="Block.html">Block</a> objects. <a
href="Block.html">Block</a> objects which represent lists may contain zero
or more <a href="ListItem.html">ListItem</a> objects.</p>

<h3 id="label-Examples">Examples</h3>

<pre class="ruby"><span class="ruby-comment"># Create a Reader for the AsciiDoc lines and retrieve the next block from it.</span>
<span class="ruby-comment"># Lexer::next_block requires a parent, so we begin by instantiating an empty Document.</span>

<span class="ruby-identifier">doc</span> = <span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">lines</span>
<span class="ruby-identifier">block</span> = <span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">doc</span>)
<span class="ruby-identifier">block</span>.<span class="ruby-identifier">class</span>
<span class="ruby-comment"># =&gt; Asciidoctor::Block</span>
</pre>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-is_single_line_section_title-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_single_line_section_title?</span><span
            class="method-args">(line1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="is_single_line_section_title-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1047</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_single_line_section_title?</span>(<span class="ruby-identifier">line1</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line1</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_title</span>]))
    <span class="ruby-identifier">single_line_section_level</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_single_line_section_title-3F-source -->
          
        </div>

        

        
      </div><!-- is_single_line_section_title-3F-method -->

    
      <div id="method-c-is_two_line_section_title-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_two_line_section_title?</span><span
            class="method-args">(line1, line2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="is_two_line_section_title-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1055</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_two_line_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line1</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line2</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_name</span>]) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_underline</span>]) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-comment"># chomp so that a (non-visible) endline does not impact calculation</span>
      (<span class="ruby-identifier">line1</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">abs</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">section_level</span> <span class="ruby-identifier">line2</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_two_line_section_title-3F-source -->
          
        </div>

        

        
      </div><!-- is_two_line_section_title-3F-method -->

    
      <div id="method-c-section_level" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">section_level</span><span
            class="method-args">(line)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Private: Get the Integer section level based on the characters used in the
ASCII line under the section title.</p>
<dl class="rdoc-list note-list"><dt>line
<dd>
<p>the String line from under the section title.</p>
</dd></dl>
          

          
          <div class="method-source-code" id="section_level-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 994</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">section_level</span>(<span class="ruby-identifier">line</span>)
  <span class="ruby-identifier">char</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">chars</span>.<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">uniq</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">char</span>
  <span class="ruby-keyword">when</span> [<span class="ruby-string">'='</span>]; <span class="ruby-value">0</span>
  <span class="ruby-keyword">when</span> [<span class="ruby-string">'-'</span>]; <span class="ruby-value">1</span>
  <span class="ruby-keyword">when</span> [<span class="ruby-string">'~'</span>]; <span class="ruby-value">2</span>
  <span class="ruby-keyword">when</span> [<span class="ruby-string">'^'</span>]; <span class="ruby-value">3</span>
  <span class="ruby-keyword">when</span> [<span class="ruby-string">'+'</span>]; <span class="ruby-value">4</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- section_level-source -->
          
        </div>

        

        
      </div><!-- section_level-method -->

    
      <div id="method-c-single_line_section_level" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">single_line_section_level</span><span
            class="method-args">(line)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="single_line_section_level-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1007</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">single_line_section_level</span>(<span class="ruby-identifier">line</span>)
  [<span class="ruby-identifier">line</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">max</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- single_line_section_level-source -->
          
        </div>

        

        
      </div><!-- single_line_section_level-method -->

    
    </section><!-- public-class-method-details -->
  
  </section><!-- 5Buntitled-5D -->

  
  
  <section id="Public" class="documentation-section">
    
    <div class="documentation-section-title">
      <h2 class="section-header">
        Public
      </h2>
      <span class="section-click-top">
        <a href="#top">&uarr; top</a>
      </span>
    </div>
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-Public-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-delimited_block-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">delimited_block?</span><span
            class="method-args">(line)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Determines whether this line is the start of any of the delimited blocks</p>

<p>returns the match data if this line is the first line of a delimited block
or nil if not</p>
          

          
          <div class="method-source-code" id="delimited_block-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 582</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">delimited_block?</span>(<span class="ruby-identifier">line</span>)
  <span class="ruby-comment"># naive match</span>
  <span class="ruby-comment">#line.match(REGEXP[:any_blk])</span>

  <span class="ruby-comment"># attempt at better performance</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-comment"># NOTE accessing the first element before calling ord is first Ruby 1.8.7 compat</span>
    <span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:any_blk_ord</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">line</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">0</span>][<span class="ruby-value">0</span>].<span class="ruby-identifier">ord</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:any_blk</span>]) <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- delimited_block-3F-source -->
          
        </div>

        

        
      </div><!-- delimited_block-3F-method -->

    
      <div id="method-c-is_section_title-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_section_title?</span><span
            class="method-args">(line1, line2 = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Checks if these lines are a section title</p>
<dl class="rdoc-list note-list"><dt>line1
<dd>
<p>the first line as a String</p>
</dd><dt>line2
<dd>
<p>the second line as a String (default: nil)</p>
</dd></dl>

<p>returns the section level if these lines are a section title, false
otherwise</p>
          

          
          <div class="method-source-code" id="is_section_title-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1037</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">level</span> = <span class="ruby-identifier">is_single_line_section_title?</span>(<span class="ruby-identifier">line1</span>))
    <span class="ruby-identifier">level</span>
  <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">level</span> = <span class="ruby-identifier">is_two_line_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span>))
    <span class="ruby-identifier">level</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_section_title-3F-source -->
          
        </div>

        

        
      </div><!-- is_section_title-3F-method -->

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Make sure the <a href="Lexer.html">Lexer</a> object doesn’t get
initialized.</p>

<p>Raises RuntimeError if this constructor is invoked.</p>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-string">'Au contraire, mon frere. No lexer instances will be running around.'</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
      <div id="method-c-next_block" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_block</span><span
            class="method-args">(reader, parent, attributes = {}, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Return the next <a href="Section.html">Section</a> or <a
href="Block.html">Block</a> object from the <a
href="Reader.html">Reader</a>.</p>

<p>Begins by skipping over blank lines to find the start of the next <a
href="Section.html">Section</a> or <a href="Block.html">Block</a>.
Processes each line of the reader in sequence until a <a
href="Section.html">Section</a> or <a href="Block.html">Block</a> is found
or the reader has no more lines.</p>

<p>Uses regular expressions from the <a
href="../Asciidoctor.html">Asciidoctor</a> module to match <a
href="Section.html">Section</a> and <a href="Block.html">Block</a>
delimiters. The ensuing lines are then processed according to the type of
content.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the next block</p>
</dd><dt>parent
<dd>
<p>The <a href="Document.html">Document</a>, <a
href="Section.html">Section</a> or <a href="Block.html">Block</a> to which
the next block belongs</p>
</dd></dl>

<p>Returns a <a href="Section.html">Section</a> or <a
href="Block.html">Block</a> object holding the parsed content of the
processed lines</p>
          

          
          <div class="method-source-code" id="next_block-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 210</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {}, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-comment"># Skip ahead to the block content</span>
  <span class="ruby-identifier">skipped</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank</span>

  <span class="ruby-comment"># bail if we've reached the end of the section content</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">skipped</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:text</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Asciidoctor</span>.<span class="ruby-identifier">debug</span> {
    <span class="ruby-identifier">msg</span> = []
    <span class="ruby-identifier">msg</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">'/'</span> * <span class="ruby-value">64</span>
    <span class="ruby-identifier">msg</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">'next_block() - First two lines are:'</span>
    <span class="ruby-identifier">msg</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>
    <span class="ruby-identifier">tmp_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
    <span class="ruby-identifier">msg</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">tmp_line</span>
    <span class="ruby-identifier">msg</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">'/'</span> * <span class="ruby-value">64</span>
    <span class="ruby-identifier">msg</span> * <span class="ruby-string">&quot;\n&quot;</span>
  }
  
  <span class="ruby-identifier">parse_metadata</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:parse_metadata</span>] <span class="ruby-operator">||</span> <span class="ruby-keyword">true</span>
  <span class="ruby-identifier">parse_sections</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:parse_sections</span>] <span class="ruby-operator">||</span> <span class="ruby-keyword">false</span>

  <span class="ruby-identifier">document</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>
  <span class="ruby-identifier">context</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Block</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">block</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parse_metadata</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span>)
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">next_line</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">parse_sections</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">context</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
      <span class="ruby-identifier">block</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>

    <span class="ruby-identifier">delimited_blk</span> = <span class="ruby-identifier">delimited_block?</span> <span class="ruby-identifier">this_line</span>

    <span class="ruby-comment"># NOTE I've haven't decided whether I want this check here or in</span>
    <span class="ruby-comment"># parse_block_metadata (where it is currently)</span>
    <span class="ruby-comment">#if this_line.match(REGEXP[:comment_blk])</span>
    <span class="ruby-comment">#  reader.grab_lines_until {|line| line.match( REGEXP[:comment_blk] ) }</span>
    <span class="ruby-comment">#  reader.skip_blank</span>
    <span class="ruby-comment">#  # NOTE we should break here because we have found a block, it</span>
    <span class="ruby-comment">#  # just happens to be nil...if we keep going we potentially overrun</span>
    <span class="ruby-comment">#  # a section heading which is not processed in this anymore</span>
    <span class="ruby-comment">#  break</span>

    <span class="ruby-comment"># NOTE we're letting ruler have attributes</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:ruler</span>])
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:ruler</span>)
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank</span>

    <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:image_blk</span>]))
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:image</span>)
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">document</span>.<span class="ruby-identifier">sub_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>])).<span class="ruby-identifier">parse_into</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'alt'</span>, <span class="ruby-string">'width'</span>, <span class="ruby-string">'height'</span>])
      <span class="ruby-identifier">target</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">sub_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>])
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">target</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'target'</span>] = <span class="ruby-identifier">target</span>
        <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:images</span>, <span class="ruby-identifier">target</span>)
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'alt'</span>] <span class="ruby-operator">||=</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">basename</span>(<span class="ruby-identifier">target</span>, <span class="ruby-constant">File</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-identifier">target</span>))
        <span class="ruby-comment"># hmmm, this assignment seems like a one-off</span>
        <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>]
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] = <span class="ruby-node">&quot;Figure #{document.counter('figure-number')}. &quot;</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># drop the line if target resolves to nothing</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-keyword">nil</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank</span>

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:open_blk</span>]))
      <span class="ruby-comment"># an open block is surrounded by '--' lines and has zero or more blocks inside</span>
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
      <span class="ruby-identifier">buffer</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>)

      <span class="ruby-comment"># Strip lines off end of block - not implemented yet</span>
      <span class="ruby-comment"># while buffer.has_lines? &amp;&amp; buffer.last.strip.empty?</span>
      <span class="ruby-comment">#   buffer.pop</span>
      <span class="ruby-comment"># end</span>

      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:open</span>)
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">has_lines?</span>
        <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">buffer</span>, <span class="ruby-identifier">block</span>)
        <span class="ruby-identifier">block</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># needs to come before list detection</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:sidebar_blk</span>]))
      <span class="ruby-comment"># sidebar is surrounded by '****' (4 or more '*' chars) lines</span>
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
      <span class="ruby-comment"># FIXME violates DRY because it's a duplication of quote parsing</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:sidebar</span>)
      <span class="ruby-identifier">buffer</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>)

      <span class="ruby-keyword">while</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">has_lines?</span>
        <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">buffer</span>, <span class="ruby-identifier">block</span>)
        <span class="ruby-identifier">block</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:colist</span>])
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:colist</span>)
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-string">'arabic'</span>
      <span class="ruby-identifier">items</span> = []
      <span class="ruby-identifier">block</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">items</span>
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">this_line</span>
      <span class="ruby-identifier">expected_index</span> = <span class="ruby-value">1</span>
      <span class="ruby-keyword">begin</span>
        <span class="ruby-comment"># might want to move this check to a validate method</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">expected_index</span>
          <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: WARNING: callout list item index: expected #{expected_index} got #{match[1]}&quot;</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">list_item</span> = <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">match</span>)
        <span class="ruby-identifier">expected_index</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">nil?</span>
          <span class="ruby-identifier">items</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">list_item</span>
          <span class="ruby-identifier">coids</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">callout_ids</span>(<span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span>)
          <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">coids</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'coids'</span>] = <span class="ruby-identifier">coids</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">puts</span> <span class="ruby-string">'asciidoctor: WARNING: no callouts refer to list item '</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span>.<span class="ruby-identifier">to_s</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:colist</span>])

      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">next_list</span>

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:ulist</span>])
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'style'</span>])
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this_line</span>)
      <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-value">:ulist</span>, <span class="ruby-identifier">parent</span>)

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:olist</span>])
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'style'</span>])
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this_line</span>)
      <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-value">:olist</span>, <span class="ruby-identifier">parent</span>)
      <span class="ruby-comment"># QUESTION move this logic to next_outline_list?</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'style'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">block</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'style'</span>)
        <span class="ruby-identifier">marker</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'.'</span>
          <span class="ruby-comment"># first one makes more sense, but second on is AsciiDoc-compliant</span>
          <span class="ruby-comment">#attributes['style'] = (ORDERED_LIST_STYLES[block.level - 1] || ORDERED_LIST_STYLES.first).to_s</span>
          <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = (<span class="ruby-constant">ORDERED_LIST_STYLES</span>[<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">first</span>).<span class="ruby-identifier">to_s</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">style</span> = <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">detect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">ORDERED_LIST_MARKER_PATTERNS</span>[<span class="ruby-identifier">s</span>]) }
          <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = (<span class="ruby-identifier">style</span> <span class="ruby-operator">||</span> <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">first</span>).<span class="ruby-identifier">to_s</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dlist</span>])
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">this_line</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_labeled_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">parent</span>)

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">document</span>.<span class="ruby-identifier">nested?</span> <span class="ruby-operator">?</span> <span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:table_nested</span>] <span class="ruby-operator">:</span> <span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:table</span>]))
      <span class="ruby-comment"># table is surrounded by lines starting with a | followed by 3 or more '=' chars</span>
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'style'</span>])
      <span class="ruby-identifier">table_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:skip_line_comments</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
      <span class="ruby-identifier">block</span> = <span class="ruby-identifier">next_table</span>(<span class="ruby-identifier">table_reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
      <span class="ruby-comment"># hmmm, this assignment seems like a one-off</span>
      <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] = <span class="ruby-node">&quot;Table #{document.counter('table-number')}. &quot;</span>
      <span class="ruby-keyword">end</span>
  
    <span class="ruby-comment"># FIXME violates DRY because it's a duplication of other block parsing</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:example</span>]))
      <span class="ruby-comment"># example is surrounded by lines with 4 or more '=' chars</span>
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'style'</span>])
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">admonition_style</span> = <span class="ruby-constant">ADMONITION_STYLES</span>.<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">s</span>}
        <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:admonition</span>)
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'name'</span>] = <span class="ruby-identifier">admonition_style</span>.<span class="ruby-identifier">downcase</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">admonition_style</span>.<span class="ruby-identifier">capitalize</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:example</span>)
        <span class="ruby-comment"># hmmm, this assignment seems like a one-off</span>
        <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>]
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] = <span class="ruby-node">&quot;Example #{document.counter('example-number')}. &quot;</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">buffer</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>)

      <span class="ruby-keyword">while</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">has_lines?</span>
        <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">buffer</span>, <span class="ruby-identifier">block</span>)
        <span class="ruby-identifier">block</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># FIXME violates DRY w/ non-delimited block listing</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:listing</span>]))
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'style'</span>, <span class="ruby-string">'language'</span>, <span class="ruby-string">'linenums'</span>])
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>)
      <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp!</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:listing</span>, <span class="ruby-identifier">buffer</span>)

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:quote</span>]))
      <span class="ruby-comment"># multi-line verse or quote is surrounded by a block delimiter</span>
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'style'</span>, <span class="ruby-string">'attribution'</span>, <span class="ruby-string">'citetitle'</span>])
      <span class="ruby-identifier">quote_context</span> = (<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'verse'</span> <span class="ruby-operator">?</span> <span class="ruby-value">:verse</span> <span class="ruby-operator">:</span> <span class="ruby-value">:quote</span>)
      <span class="ruby-identifier">block_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>)

      <span class="ruby-comment"># only quote can have other section elements (as as section block)</span>
      <span class="ruby-identifier">section_body</span> = (<span class="ruby-identifier">quote_context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:quote</span>)

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">section_body</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">quote_context</span>)
        <span class="ruby-keyword">while</span> <span class="ruby-identifier">block_reader</span>.<span class="ruby-identifier">has_lines?</span>
          <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">block_reader</span>, <span class="ruby-identifier">block</span>)
          <span class="ruby-identifier">block</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">block_reader</span>.<span class="ruby-identifier">chomp_last!</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">quote_context</span>, <span class="ruby-identifier">block_reader</span>.<span class="ruby-identifier">lines</span>)
      <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">delimited_blk</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">blk_ctx</span> = [<span class="ruby-value">:literal</span>, <span class="ruby-value">:pass</span>].<span class="ruby-identifier">detect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">t</span>])})
      <span class="ruby-comment"># literal is surrounded by '....' (4 or more '.' chars) lines</span>
      <span class="ruby-comment"># pass is surrounded by '++++' (4 or more '+' chars) lines</span>
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">$~</span>[<span class="ruby-value">0</span>]
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>)
      <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp!</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-comment"># a literal can masquerade as a listing</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'listing'</span>
        <span class="ruby-identifier">blk_ctx</span> = <span class="ruby-value">:listing</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">blk_ctx</span>, <span class="ruby-identifier">buffer</span>)

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
      <span class="ruby-comment"># literal paragraph is contiguous lines starting with</span>
      <span class="ruby-comment"># one or more space or tab characters</span>

      <span class="ruby-comment"># So we need to actually include this one in the grab_lines group</span>
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">this_line</span>
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
        <span class="ruby-comment"># labeled list terms can be indented, but a preceding blank indicates</span>
        <span class="ruby-comment"># we are in a list continuation and therefore literals should be strictly literal</span>
        (<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">skipped</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dlist</span>])) <span class="ruby-operator">||</span>
        <span class="ruby-identifier">delimited_block?</span>(<span class="ruby-identifier">line</span>)
      }

      <span class="ruby-comment"># trim off the indentation equivalent to the size of the least indented line</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-identifier">offset</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:leading_blanks</span>])[<span class="ruby-value">1</span>].<span class="ruby-identifier">length</span> }.<span class="ruby-identifier">min</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">offset</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
          <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-node">%r^\s{1,#{offset}}/</span>, <span class="ruby-string">''</span>) }
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp!</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:literal</span>, <span class="ruby-identifier">buffer</span>)
      <span class="ruby-comment"># a literal gets special meaning inside of a definition list</span>
      <span class="ruby-keyword">if</span> <span class="ruby-constant">LIST_CONTEXTS</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">context</span>)
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'options'</span>] <span class="ruby-operator">||=</span> []
        <span class="ruby-comment"># TODO this feels hacky, better way to distinguish from explicit literal block?</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'options'</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">'listparagraph'</span>
      <span class="ruby-keyword">end</span>

    <span class="ruby-comment">## these switches based on style need to come immediately before the else ##</span>

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'source'</span>
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'style'</span>, <span class="ruby-string">'language'</span>, <span class="ruby-string">'linenums'</span>])
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this_line</span>)
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
      <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp!</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:listing</span>, <span class="ruby-identifier">buffer</span>)

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">admonition_style</span> = <span class="ruby-constant">ADMONITION_STYLES</span>.<span class="ruby-identifier">detect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">s</span>}
      <span class="ruby-comment"># an admonition preceded by [&lt;TYPE&gt;] and lasts until a blank line</span>
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this_line</span>)
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
      <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp!</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:admonition</span>, <span class="ruby-identifier">buffer</span>)
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">admonition_style</span>
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'name'</span>] = <span class="ruby-identifier">admonition_style</span>.<span class="ruby-identifier">downcase</span>
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">admonition_style</span>.<span class="ruby-identifier">capitalize</span>

    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">quote_context</span> = [<span class="ruby-value">:quote</span>, <span class="ruby-value">:verse</span>].<span class="ruby-identifier">detect</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">to_s</span>}
      <span class="ruby-comment"># single-paragraph verse or quote is preceded by [verse] or [quote], respectively, and lasts until a blank line</span>
      <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">rekey</span>(<span class="ruby-identifier">attributes</span>, [<span class="ruby-string">'style'</span>, <span class="ruby-string">'attribution'</span>, <span class="ruby-string">'citetitle'</span>])
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this_line</span>)
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
      <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp!</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">quote_context</span>, <span class="ruby-identifier">buffer</span>)

    <span class="ruby-comment"># a floating (i.e., discrete) title</span>
    <span class="ruby-keyword">elsif</span> [<span class="ruby-string">'float'</span>, <span class="ruby-string">'discrete'</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">is_section_title?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>)
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>]
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">this_line</span>
      <span class="ruby-identifier">float_id</span>, <span class="ruby-identifier">float_title</span>, <span class="ruby-identifier">float_level</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_section_title</span> <span class="ruby-identifier">reader</span>
      <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:floating_title</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">float_id</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">float_id</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-comment"># FIXME remove hack of creating throwaway Section to get at the generate_id method</span>
        <span class="ruby-identifier">tmp_sect</span> = <span class="ruby-constant">Section</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>)
        <span class="ruby-identifier">tmp_sect</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">float_title</span>
        <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">tmp_sect</span>.<span class="ruby-identifier">generate_id</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">float_id</span>
        <span class="ruby-ivar">@document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">float_id</span>, <span class="ruby-identifier">float_title</span>])
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">float_level</span>
      <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">float_title</span>

    <span class="ruby-comment"># a paragraph - contiguous nonblank/noncontinuation lines</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">this_line</span>
      <span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:skip_line_comments</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">delimited_block?</span>(<span class="ruby-identifier">line</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>]) <span class="ruby-operator">||</span>
        <span class="ruby-comment"># next list item can be directly adjacent to paragraph of previous list item</span>
        <span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dlist</span>])
        <span class="ruby-comment"># not sure if there are any cases when we need this check for other list types</span>
        <span class="ruby-comment">#LIST_CONTEXTS.include?(context) &amp;&amp; line.match(REGEXP[context])</span>
      }

      <span class="ruby-comment"># NOTE we need this logic because the reader is processing line</span>
      <span class="ruby-comment"># comments and that might leave us w/ an empty buffer</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">catalog_inline_anchors</span>(<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">join</span>, <span class="ruby-identifier">document</span>)

      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">admonition</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">'^('</span> <span class="ruby-operator">+</span> <span class="ruby-constant">ADMONITION_STYLES</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">'|'</span>) <span class="ruby-operator">+</span> <span class="ruby-string">'):\s+'</span>)))
        <span class="ruby-identifier">buffer</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">admonition</span>.<span class="ruby-identifier">post_match</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:admonition</span>, <span class="ruby-identifier">buffer</span>)
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-identifier">admonition</span>[<span class="ruby-value">1</span>]
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'name'</span>] = <span class="ruby-identifier">admonition</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">downcase</span>
        <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">admonition</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">capitalize</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp!</span>
        <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:paragraph</span>, <span class="ruby-identifier">buffer</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># when looking for nested content, one or more line comments, comment</span>
  <span class="ruby-comment"># blocks or trailing attribute lists could leave us without a block,</span>
  <span class="ruby-comment"># so handle accordingly</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>        = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'id'</span>)
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span>     = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">caption</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'caption'</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Section</span>)
    <span class="ruby-comment"># AsciiDoc always use [id] as the reftext in HTML output,</span>
    <span class="ruby-comment"># but I'd like to do better in Asciidoctor</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'reftext'</span>)
      <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">block</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">block</span>.<span class="ruby-identifier">title</span>])
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">block</span>.<span class="ruby-identifier">update_attributes</span>(<span class="ruby-identifier">attributes</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:listing</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-value">:literal</span>
      <span class="ruby-identifier">catalog_callouts</span>(<span class="ruby-identifier">block</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">join</span>, <span class="ruby-identifier">document</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_block-source -->
          
        </div>

        

        
      </div><!-- next_block-method -->

    
      <div id="method-c-next_section" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_section</span><span
            class="method-args">(reader, parent, attributes = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Return the next section from the <a href="Reader.html">Reader</a>.</p>

<p>This method process block metadata, content and subsections for this
section and returns the <a href="Section.html">Section</a> object and any
orphaned attributes.</p>

<p>If the parent is a <a href="Document.html">Document</a> and has a header
(document title), then this method will put any non-section blocks at the
start of document into a preamble <a href="Block.html">Block</a>. If there
are no such blocks, the preamble is dropped.</p>

<p>Since we are reading line-by-line, there’s a chance that metadata that
should be associated with the following block gets consumed. To deal with
this case, the method returns a running Hash of “orphaned” attributes that
get passed to the next <a href="Section.html">Section</a> or <a
href="Block.html">Block</a>.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source <a href="Reader.html">Reader</a></p>
</dd><dt>parent
<dd>
<p>the parent <a href="Section.html">Section</a> or <a
href="Document.html">Document</a> of this new section</p>
</dd><dt>attributes
<dd>
<p>a Hash of metadata that was left orphaned from the previous <a
href="Section.html">Section</a>.</p>
</dd></dl>

<h3 id="method-c-next_section-label-Examples">Examples</h3>

<pre class="ruby"><span class="ruby-identifier">source</span>
<span class="ruby-comment"># =&gt; &quot;Greetings\n---------\nThis is my doc.\n\nSalutations\n-----------\nIt is awesome.&quot;</span>

<span class="ruby-identifier">reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">source</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">entries</span>
<span class="ruby-comment"># create empty document to parent the section</span>
<span class="ruby-comment"># and hold attributes extracted from header</span>
<span class="ruby-identifier">doc</span> = <span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>

<span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">doc</span>).<span class="ruby-identifier">first</span>.<span class="ruby-identifier">title</span>
<span class="ruby-comment"># =&gt; &quot;Greetings&quot;</span>

<span class="ruby-constant">Lexer</span>.<span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">doc</span>).<span class="ruby-identifier">first</span>.<span class="ruby-identifier">title</span>
<span class="ruby-comment"># =&gt; &quot;Salutations&quot;</span>
</pre>

<p>returns a two-element Array containing the <a
href="Section.html">Section</a> and Hash of orphaned attributes</p>
          

          
          <div class="method-source-code" id="next_section-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 103</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {})
  <span class="ruby-identifier">preamble</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-comment"># check if we are at the start of processing the document</span>
  <span class="ruby-comment"># NOTE we could drop a hint in the attributes to indicate</span>
  <span class="ruby-comment"># that we are at a section title (so we don't have to check)</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Document</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">blocks</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span>
      (<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">has_header?</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>))

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">has_header?</span>
      <span class="ruby-identifier">preamble</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:preamble</span>)
      <span class="ruby-identifier">parent</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">preamble</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">section</span> = <span class="ruby-identifier">parent</span>

    <span class="ruby-identifier">current_level</span> = <span class="ruby-value">0</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'fragment'</span>
      <span class="ruby-identifier">expected_next_levels</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-comment"># small tweak to allow subsequent level-0 sections for book doctype</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">doctype</span> <span class="ruby-operator">==</span> <span class="ruby-string">'book'</span>
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">section</span> = <span class="ruby-identifier">initialize_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
    <span class="ruby-comment"># clear attributes, except for title which carries over</span>
    <span class="ruby-comment"># section title to next block of content</span>
    <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'title'</span>}
    <span class="ruby-identifier">current_level</span> = <span class="ruby-identifier">section</span>.<span class="ruby-identifier">level</span>
    <span class="ruby-identifier">expected_next_levels</span> = [<span class="ruby-identifier">current_level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-comment"># Parse lines belonging to this section and its subsections until we</span>
  <span class="ruby-comment"># reach the end of this section level</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># 1. first look for metadata thingies (anchor, attribute list, block title line, etc)</span>
  <span class="ruby-comment"># 2. then look for a section, recurse if found</span>
  <span class="ruby-comment"># 3. then process blocks</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># We have to parse all the metadata lines before continuing with the loop,</span>
  <span class="ruby-comment"># otherwise subsequent metadata lines get interpreted as block content</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span>
    <span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">section</span>, <span class="ruby-identifier">attributes</span>)

    <span class="ruby-identifier">next_level</span> = <span class="ruby-identifier">is_next_line_section?</span> <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span>
      <span class="ruby-identifier">doctype</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">doctype</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">doctype</span> <span class="ruby-operator">!=</span> <span class="ruby-string">'book'</span>
        <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;asciidoctor: ERROR: only book doctypes can contain level 0 sections&quot;</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">current_level</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">section</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Document</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>)
        <span class="ruby-keyword">unless</span> <span class="ruby-identifier">expected_next_levels</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">expected_next_levels</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">next_level</span>)
          <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;asciidoctor: WARNING: section title out of sequence: &quot;</span> <span class="ruby-operator">+</span>
              <span class="ruby-node">&quot;expected #{expected_next_levels.size &gt; 1 ? 'levels' : 'level'} #{expected_next_levels * ' or '}, &quot;</span> <span class="ruby-operator">+</span>
              <span class="ruby-node">&quot;got level #{next_level}&quot;</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-comment"># the attributes returned are those that are orphaned</span>
        <span class="ruby-identifier">new_section</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">section</span>, <span class="ruby-identifier">attributes</span>)
        <span class="ruby-identifier">section</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_section</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># close this section (and break out of the nesting) to begin a new one</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-comment"># just take one block or else we run the risk of overrunning section boundaries</span>
      <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">section</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-value">:parse_metadata</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
        (<span class="ruby-identifier">preamble</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">section</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span>
        <span class="ruby-identifier">attributes</span> = {}
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># don't clear attributes if we don't find a block because they may</span>
        <span class="ruby-comment"># be trailing attributes that didn't get associated with a block</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># prune the preamble if it has no content</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">preamble</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">preamble</span>.<span class="ruby-identifier">blocks</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-value">0</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># The attributes returned here are orphaned attributes that fall at the end</span>
  <span class="ruby-comment"># of a section that need to get transfered to the next section</span>
  <span class="ruby-comment"># see &quot;trailing block attributes transfer to the following section&quot; in</span>
  <span class="ruby-comment"># test/attributes_test.rb for an example</span>
  [<span class="ruby-identifier">section</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">parent</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">section</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">dup</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_section-source -->
          
        </div>

        

        
      </div><!-- next_section-method -->

    
      <div id="method-c-parse" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse</span><span
            class="method-args">(reader, document)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parses AsciiDoc source read from the <a href="Reader.html">Reader</a> into
the <a href="Document.html">Document</a></p>

<p>This method is the main entry-point into the <a href="Lexer.html">Lexer</a>
when parsing a full document. It first looks for and, if found, processes
the document title. It then proceeds to iterate through the lines in the <a
href="Reader.html">Reader</a>, parsing the document into nested Sections
and Blocks.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the <a href="Reader.html">Reader</a> holding the source lines of the
document</p>
</dd><dt>document
<dd>
<p>the empty <a href="Document.html">Document</a> into which the lines will be
parsed</p>
</dd></dl>

<p>returns the <a href="Document.html">Document</a> object</p>
          

          
          <div class="method-source-code" id="parse-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 45</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-comment"># process and plow away any attribute lines that proceed the first block so</span>
  <span class="ruby-comment"># we can get at the document title, if present, then begin parsing blocks</span>
  <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)

  <span class="ruby-comment"># by processing the header here, we enforce its position at head of the document  </span>
  <span class="ruby-identifier">next_level</span> = <span class="ruby-identifier">is_next_line_section?</span> <span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_level</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">title_info</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>) 
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">title</span> = <span class="ruby-identifier">title_info</span>[<span class="ruby-value">1</span>]
    <span class="ruby-identifier">parse_header_metadata</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span>
    <span class="ruby-identifier">new_section</span>, <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">next_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span>, <span class="ruby-identifier">attributes</span>)
    <span class="ruby-identifier">document</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_section</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_section</span>.<span class="ruby-identifier">nil?</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">document</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse-source -->
          
        </div>

        

        
      </div><!-- parse-method -->

    
      <div id="method-c-parse_header_metadata" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_header_metadata</span><span
            class="method-args">(reader, document = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Consume and parse the two header lines (line 1 = author info, line 2 =
revision info).</p>

<p>Returns the Hash of header metadata. If a <a
href="Document.html">Document</a> object is supplied, the metadata is
applied directly to the attributes of the <a
href="Document.html">Document</a>.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the <a href="Reader.html">Reader</a> holding the source lines of the
document</p>
</dd><dt>document
<dd>
<p>the <a href="Document.html">Document</a> we are building (default: nil)</p>
</dd></dl>

<h3 id="method-c-parse_header_metadata-label-Examples">Examples</h3>

<pre class="ruby"><span class="ruby-identifier">parse_header_metadata</span>(<span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> [<span class="ruby-string">&quot;Author Name &lt;author@example.org&gt;\n&quot;</span>, <span class="ruby-string">&quot;v1.0, 2012-12-21: Coincide w/ end of world.\n&quot;</span>])
<span class="ruby-comment"># =&gt; {'author' =&gt; 'Author Name', 'firstname' =&gt; 'Author', 'lastname' =&gt; 'Name', 'email' =&gt; 'author@example.org',</span>
<span class="ruby-comment">#       'revnumber' =&gt; '1.0', 'revdate' =&gt; '2012-12-21', 'revremark' =&gt; 'Coincide w/ end of world.'}</span>
</pre>
          

          
          <div class="method-source-code" id="parse_header_metadata-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1152</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_header_metadata</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">document</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-comment"># capture consecutive comment lines so we can reinsert them after the header</span>
  <span class="ruby-identifier">comment_lines</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">consume_comments</span>

  <span class="ruby-identifier">metadata</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">document</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">attributes</span> <span class="ruby-operator">:</span> {}
  <span class="ruby-identifier">author_initials</span> = <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'authorinitials'</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">author_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
    <span class="ruby-identifier">match</span> = <span class="ruby-identifier">author_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:author_info</span>])
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span>
      <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'firstname'</span>] = <span class="ruby-identifier">fname</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
      <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'author'</span>] = <span class="ruby-identifier">fname</span>
      <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'authorinitials'</span>] = <span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'middlename'</span>] = <span class="ruby-identifier">mname</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'lastname'</span>] = <span class="ruby-identifier">lname</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'author'</span>] = [<span class="ruby-identifier">fname</span>, <span class="ruby-identifier">mname</span>, <span class="ruby-identifier">lname</span>].<span class="ruby-identifier">join</span> <span class="ruby-string">' '</span>
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'authorinitials'</span>] = [<span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">mname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">lname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]].<span class="ruby-identifier">join</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'lastname'</span>] = <span class="ruby-identifier">lname</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">tr</span>(<span class="ruby-string">'_'</span>, <span class="ruby-string">' '</span>)
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'author'</span>] = [<span class="ruby-identifier">fname</span>, <span class="ruby-identifier">lname</span>].<span class="ruby-identifier">join</span> <span class="ruby-string">' '</span>
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'authorinitials'</span>] = [<span class="ruby-identifier">fname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>], <span class="ruby-identifier">lname</span>[<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]].<span class="ruby-identifier">join</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'email'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">4</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">4</span>].<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'author'</span>] = <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'firstname'</span>] = <span class="ruby-identifier">author_line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-string">' '</span>)
      <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'authorinitials'</span>] = <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'firstname'</span>][<span class="ruby-value">0</span>, <span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># hack because of incorrect order of attribute processing</span>
    <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'authorinitials'</span>] = <span class="ruby-identifier">author_initials</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">author_initials</span>.<span class="ruby-identifier">nil?</span>

    <span class="ruby-comment"># capture consecutive comment lines so we can reinsert them after the header</span>
    <span class="ruby-identifier">comment_lines</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">consume_comments</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-identifier">rev_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span> 
      <span class="ruby-identifier">match</span> = <span class="ruby-identifier">rev_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:revision_info</span>])
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span>
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'revdate'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'revnumber'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span>
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'revremark'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">metadata</span>[<span class="ruby-string">'revdate'</span>] = <span class="ruby-identifier">rev_line</span>.<span class="ruby-identifier">strip</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span>(*<span class="ruby-identifier">comment_lines</span>)
  <span class="ruby-identifier">metadata</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_header_metadata-source -->
          
        </div>

        

        
      </div><!-- parse_header_metadata-method -->

    
    </section><!-- public-class-method-details -->
  
  </section><!-- Public -->

  
  
  <section id="Internal" class="documentation-section">
    
    <div class="documentation-section-title">
      <h2 class="section-header">
        Internal
      </h2>
      <span class="section-click-top">
        <a href="#top">&uarr; top</a>
      </span>
    </div>
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-Internal-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-catalog_callouts" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">catalog_callouts</span><span
            class="method-args">(text, document)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Catalog any callouts found in the text, but don’t process them</p>
<dl class="rdoc-list note-list"><dt>text
<dd>
<p>The String of text in which to look for callouts</p>
</dd><dt>document
<dd>
<p>The current document on which the callouts are stored</p>
</dd></dl>

<p>Returns nothing</p>
          

          
          <div class="method-source-code" id="catalog_callouts-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 661</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">catalog_callouts</span>(<span class="ruby-identifier">text</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">text</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:callout_scan</span>]) {
    <span class="ruby-comment"># alias match for Ruby 1.8.7 compat</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">$~</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'\'</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">callouts</span>.<span class="ruby-identifier">register</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>])
  }
<span class="ruby-keyword">end</span></pre>
          </div><!-- catalog_callouts-source -->
          
        </div>

        

        
      </div><!-- catalog_callouts-method -->

    
      <div id="method-c-catalog_inline_anchors" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">catalog_inline_anchors</span><span
            class="method-args">(text, document)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Catalog any inline anchors found in the text, but don’t process them</p>
<dl class="rdoc-list note-list"><dt>text
<dd>
<p>The String text in which to look for inline anchors</p>
</dd><dt>document
<dd>
<p>The current document on which the references are stored</p>
</dd></dl>

<p>Returns nothing</p>
          

          
          <div class="method-source-code" id="catalog_inline_anchors-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 676</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">catalog_inline_anchors</span>(<span class="ruby-identifier">text</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-identifier">text</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor_macro</span>]) {
    <span class="ruby-comment"># alias match for Ruby 1.8.7 compat</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">$~</span>
    <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">start_with?</span> <span class="ruby-string">'\'</span>
    <span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>)
    <span class="ruby-identifier">id</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp">%r^(&quot;|)(.*)\11$$/</span>, <span class="ruby-string">'\2'</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reftext</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">reftext</span>.<span class="ruby-identifier">sub!</span>(<span class="ruby-regexp">%r^(&quot;|)(.*)\11$$/</span>, <span class="ruby-string">'\2'</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span>])
  }
  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- catalog_inline_anchors-source -->
          
        </div>

        

        
      </div><!-- catalog_inline_anchors-method -->

    
      <div id="method-c-grab_lines_for_list_item" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">grab_lines_for_list_item</span><span
            class="method-args">(reader, list_type, sibling_trait = nil, has_text = true)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Collect the lines belonging to the current list item, navigating through
all the rules that determine what comprises a list item.</p>

<p>Grab lines until a sibling list item is found, or the block is broken by a
terminator (such as a line comment). Definition lists are more greedy if
they don’t have optional inline item text…they want that text</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the lines.</p>
</dd><dt>list_type
<dd>
<p>The Symbol context of the list (:ulist, :olist, :colist or :dlist)</p>
</dd><dt>sibling_trait
<dd>
<p>A Regexp that matches a sibling of this list item or String list marker  of
the items in this list (default: nil)</p>
</dd><dt>has_text
<dd>
<p>Whether the list item has text defined inline (always true except for
labeled lists)</p>
</dd></dl>

<p>Returns an Array of lines belonging to the current list item.</p>
          

          
          <div class="method-source-code" id="grab_lines_for_list_item-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 799</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">grab_lines_for_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">buffer</span> = []

  <span class="ruby-comment"># three states for continuation: :inactive, :active &amp; :frozen</span>
  <span class="ruby-comment"># :frozen signifies we've detected sequential continuation lines &amp;</span>
  <span class="ruby-comment"># continuation is not permitted until reset </span>
  <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>

  <span class="ruby-comment"># if we are within a nested list, we don't throw away the list</span>
  <span class="ruby-comment"># continuation marks because they will be processed when grabbing</span>
  <span class="ruby-comment"># the lines for those nested lists</span>
  <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-comment"># a detached continuation is a list continuation that follows a blank line</span>
  <span class="ruby-comment"># it gets associated with the outermost block</span>
  <span class="ruby-identifier">detached_continuation</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span>
    <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>

    <span class="ruby-comment"># if we've arrived at a sibling item in this list, we've captured</span>
    <span class="ruby-comment"># the complete list item and can begin processing it</span>
    <span class="ruby-comment"># the remainder of the method determines whether we've reached</span>
    <span class="ruby-comment"># the termination of the list</span>
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)

    <span class="ruby-identifier">prev_line</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">prev_line</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:inactive</span>
        <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:active</span>
        <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
        <span class="ruby-identifier">buffer</span>[<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>] = <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">within_nested_list</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># dealing with adjacent list continuations (which is really a syntax error)</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:frozen</span>
          <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:frozen</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">this_line</span> = <span class="ruby-keyword">nil</span>
        <span class="ruby-keyword">next</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># a delimited block immediately breaks the list unless preceded</span>
    <span class="ruby-comment"># by a list continuation (they are harsh like that ;0)</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">delimited_block?</span>(<span class="ruby-identifier">this_line</span>)) <span class="ruby-operator">||</span>
      <span class="ruby-comment"># technically attr_line only breaks if ensuing line is not a list item</span>
      <span class="ruby-comment"># which really means attr_line only breaks if it's acting as a block delimiter</span>
      (<span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:attr_line</span>]))
      <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:active</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-comment"># grab all the lines in the block, leaving the delimiters in place</span>
        <span class="ruby-comment"># we're being more strict here about the terminator, but I think that's a good thing</span>
        <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>, <span class="ruby-value">:grab_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
        <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">continuation</span> <span class="ruby-operator">==</span> <span class="ruby-value">:active</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-comment"># literal paragraphs have special considerations (and this is one of </span>
        <span class="ruby-comment"># two entry points into one)</span>
        <span class="ruby-comment"># if we don't process it as a whole, then a line in it that looks like a</span>
        <span class="ruby-comment"># list item will throw off the exit from it</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">this_line</span>
          <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(
            <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
            <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
            <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> = (<span class="ruby-identifier">within_nested_list</span> <span class="ruby-operator">?</span> [<span class="ruby-value">:dlist</span>] <span class="ruby-operator">:</span> <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>).<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
            <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
              <span class="ruby-comment"># get greedy again</span>
              <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">continuation</span> = <span class="ruby-value">:inactive</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">prev_line</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prev_line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-comment"># advance to the next line of content</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank</span>
          <span class="ruby-identifier">this_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span> 
          <span class="ruby-comment"># if we hit eof or a sibling, stop reading</span>
          <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
        <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
          <span class="ruby-identifier">detached_continuation</span> = <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span>
          <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-comment"># has_text is only relevant for dlist, which is more greedy until it has text for an item</span>
          <span class="ruby-comment"># for all other lists, has_text is always true</span>
          <span class="ruby-comment"># in this block, we have to see whether we stay in the list</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">has_text</span>
            <span class="ruby-comment"># slurp up any literal paragraph offset by blank lines</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:lit_par</span>])
              <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">this_line</span>
              <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">concat</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(
                <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                <span class="ruby-value">:break_on_blank_lines</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                <span class="ruby-value">:break_on_list_continuation</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
            <span class="ruby-comment"># TODO any way to combine this with the check after skipping blank lines?</span>
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">this_line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
              <span class="ruby-comment">#buffer.pop unless within_nested_list</span>
              <span class="ruby-keyword">break</span>
            <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">nested_list_type</span> = <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>.<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
              <span class="ruby-comment">#buffer.pop unless within_nested_list</span>
              <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
              <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
              <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
                <span class="ruby-comment"># get greedy again</span>
                <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
              <span class="ruby-keyword">end</span>
            <span class="ruby-keyword">else</span>
              <span class="ruby-keyword">break</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">else</span> <span class="ruby-comment"># only dlist in need of item text, so slurp it up!</span>
            <span class="ruby-comment"># pop the blank line so it's not interpretted as a list continuation</span>
            <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">within_nested_list</span>
            <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
            <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> = (<span class="ruby-identifier">within_nested_list</span> <span class="ruby-operator">?</span> [<span class="ruby-value">:dlist</span>] <span class="ruby-operator">:</span> <span class="ruby-constant">NESTABLE_LIST_CONTEXTS</span>).<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ctx</span><span class="ruby-operator">|</span> <span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">ctx</span>]) }
          <span class="ruby-identifier">within_nested_list</span> = <span class="ruby-keyword">true</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">nested_list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">$~</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
            <span class="ruby-comment"># get greedy again</span>
            <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">false</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_line</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">this_line</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">this_line</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this_line</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">detached_continuation</span>
    <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">delete_at</span> <span class="ruby-identifier">detached_continuation</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># QUESTION should we strip these trailing endlines?</span>
  <span class="ruby-comment">#buffer.pop while buffer.last == &quot;\n&quot;</span>

  <span class="ruby-comment"># We do need to replace the optional trailing continuation</span>
  <span class="ruby-comment"># a blank line would have served the same purpose in the document</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">chomp</span> <span class="ruby-operator">==</span> <span class="ruby-constant">LIST_CONTINUATION</span>
    <span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">pop</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment">#puts &quot;BUFFER&gt;#{buffer.join}&lt;BUFFER&quot;</span>
  <span class="ruby-comment">#puts &quot;BUFFER&gt;#{buffer}&lt;BUFFER&quot;</span>

  <span class="ruby-identifier">buffer</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- grab_lines_for_list_item-source -->
          
        </div>

        

        
      </div><!-- grab_lines_for_list_item-method -->

    
      <div id="method-c-initialize_section" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">initialize_section</span><span
            class="method-args">(reader, parent, attributes = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Initialize a new <a href="Section.html">Section</a> object and assign any
attributes provided</p>

<p>The information for this section is retrieved by parsing the lines at the
current position of the reader.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source reader</p>
</dd><dt>parent
<dd>
<p>the parent <a href="Section.html">Section</a> or <a
href="Document.html">Document</a> of this <a
href="Section.html">Section</a></p>
</dd><dt>attributes
<dd>
<p>a Hash of attributes to assign to this section (default: {})</p>
</dd></dl>
          

          
          <div class="method-source-code" id="initialize_section-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 973</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">initialize_section</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {})
  <span class="ruby-identifier">section</span> = <span class="ruby-constant">Section</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">parent</span>
  <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">section</span>.<span class="ruby-identifier">title</span>, <span class="ruby-identifier">section</span>.<span class="ruby-identifier">level</span>, <span class="ruby-identifier">_</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'id'</span>)
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># generate an id if one was not *embedded* in the heading line</span>
    <span class="ruby-comment"># or as an anchor above the section</span>
    <span class="ruby-identifier">section</span>.<span class="ruby-identifier">id</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">generate_id</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">section</span>.<span class="ruby-identifier">update_attributes</span>(<span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank</span>

  <span class="ruby-identifier">section</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- initialize_section-source -->
          
        </div>

        

        
      </div><!-- initialize_section-method -->

    
      <div id="method-c-is_next_line_section-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_next_line_section?</span><span
            class="method-args">(reader, attributes)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Checks if the next line on the <a href="Reader.html">Reader</a> is a
section title</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source <a href="Reader.html">Reader</a></p>
</dd></dl>

<p>returns the section level if the <a href="Reader.html">Reader</a> is
positioned at a section title, false otherwise</p>
          

          
          <div class="method-source-code" id="is_next_line_section-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1017</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_next_line_section?</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> [<span class="ruby-string">'float'</span>, <span class="ruby-string">'discrete'</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">attributes</span>[<span class="ruby-value">1</span>])
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span>
    <span class="ruby-identifier">line1</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
    <span class="ruby-identifier">line2</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">line1</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">is_section_title?</span>(<span class="ruby-identifier">line1</span>, <span class="ruby-identifier">line2</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_next_line_section-3F-source -->
          
        </div>

        

        
      </div><!-- is_next_line_section-3F-method -->

    
      <div id="method-c-is_sibling_list_item-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_sibling_list_item?</span><span
            class="method-args">(line, list_type, sibling_trait)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Determine whether the this line is a sibling list item according to the
list type and trait (marker) provided.</p>
<dl class="rdoc-list note-list"><dt>line
<dd>
<p>The String line to check</p>
</dd><dt>list_type
<dd>
<p>The context of the list (:olist, :ulist, :colist, :dlist)</p>
</dd><dt>sibling_trait
<dd>
<p>The String marker for the list or the Regexp to match a sibling</p>
</dd></dl>

<p>Returns a Boolean indicating whether this line is a sibling list item given
the criteria provided</p>
          

          
          <div class="method-source-code" id="is_sibling_list_item-3F-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1382</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_sibling_list_item?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sibling_trait</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Regexp</span>)
    <span class="ruby-identifier">matcher</span> = <span class="ruby-identifier">sibling_trait</span>
    <span class="ruby-identifier">expected_marker</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">matcher</span> = <span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">list_type</span>]
    <span class="ruby-identifier">expected_marker</span> = <span class="ruby-identifier">sibling_trait</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">matcher</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">expected_marker</span>
      <span class="ruby-identifier">expected_marker</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>])
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_sibling_list_item-3F-source -->
          
        </div>

        

        
      </div><!-- is_sibling_list_item-3F-method -->

    
      <div id="method-c-next_labeled_list" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_labeled_list</span><span
            class="method-args">(reader, match, parent)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse and construct a labeled (e.g., definition) list <a
href="Block.html">Block</a> from the current position of the <a
href="Reader.html">Reader</a></p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the labeled
list</p>
</dd><dt>match
<dd>
<p>The Regexp match for the head of the list</p>
</dd><dt>parent
<dd>
<p>The parent <a href="Block.html">Block</a> to which this labeled list
belongs</p>
</dd></dl>

<p>Returns the <a href="Block.html">Block</a> encapsulating the parsed labeled
list</p>
          

          
          <div class="method-source-code" id="next_labeled_list-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 698</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_labeled_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">parent</span>)
  <span class="ruby-identifier">pairs</span> = []
  <span class="ruby-identifier">block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-value">:dlist</span>)
  <span class="ruby-identifier">block</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">pairs</span>
  <span class="ruby-comment"># allows us to capture until we find a labeled item</span>
  <span class="ruby-comment"># that uses the same delimiter (::, :::, :::: or ;;)</span>
  <span class="ruby-identifier">sibling_pattern</span> = <span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:dlist_siblings</span>][<span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]]

  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">pairs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">sibling_pattern</span>)
  <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">sibling_pattern</span>)

  <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_labeled_list-source -->
          
        </div>

        

        
      </div><!-- next_labeled_list-method -->

    
      <div id="method-c-next_list_item" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_list_item</span><span
            class="method-args">(reader, list_block, match, sibling_trait = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse and construct the next <a href="ListItem.html">ListItem</a> for the
current bulleted (unordered or ordered) list <a
href="Block.html">Block</a>, callout lists included, or the next term <a
href="ListItem.html">ListItem</a> and definition <a
href="ListItem.html">ListItem</a> pair for the labeled list <a
href="Block.html">Block</a>.</p>

<p>First collect and process all the lines that constitute the next list item
for the parent list (according to its type). Next, parse those lines into
blocks and associate them with the <a href="ListItem.html">ListItem</a> (in
the case of a labeled list, the definition <a
href="ListItem.html">ListItem</a>). Finally, fold the first block into the
item’s text attribute according to rules described in <a
href="ListItem.html">ListItem</a>.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the next list
item</p>
</dd><dt>list_block
<dd>
<p>The parent list <a href="Block.html">Block</a> of this <a
href="ListItem.html">ListItem</a>. Also provides access to the list type.</p>
</dd><dt>match
<dd>
<p>The match Array which contains the marker and text (first-line) of the <a
href="ListItem.html">ListItem</a></p>
</dd><dt>sibling_trait
<dd>
<p>The list marker or the Regexp to match a sibling item</p>
</dd></dl>

<p>Returns the next <a href="ListItem.html">ListItem</a> or <a
href="ListItem.html">ListItem</a> pair (depending on the list type) for the
parent list <a href="Block.html">Block</a>.</p>
          

          
          <div class="method-source-code" id="next_list_item-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 730</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">list_type</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">context</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span>
    <span class="ruby-identifier">list_term</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>])
    <span class="ruby-identifier">list_item</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>])
    <span class="ruby-identifier">has_text</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Create list item using first line as the text of the list item</span>
    <span class="ruby-identifier">list_item</span> = <span class="ruby-constant">ListItem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>])

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">sibling_trait</span>
      <span class="ruby-identifier">sibling_trait</span> = <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">size</span>, <span class="ruby-keyword">true</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">marker</span> = <span class="ruby-identifier">sibling_trait</span>
    <span class="ruby-identifier">has_text</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># first skip the line with the marker / term</span>
  <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
  <span class="ruby-identifier">list_item_reader</span> = <span class="ruby-constant">Reader</span>.<span class="ruby-identifier">new</span> <span class="ruby-identifier">grab_lines_for_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">sibling_trait</span>, <span class="ruby-identifier">has_text</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">has_lines?</span>
    <span class="ruby-identifier">comment_lines</span> = <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">consume_line_comments</span>
    <span class="ruby-identifier">subsequent_line</span> = <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">peek_line</span>
    <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">unshift</span>(*<span class="ruby-identifier">comment_lines</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">comment_lines</span>.<span class="ruby-identifier">empty?</span> 

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">subsequent_line</span>.<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">continuation_connects_first_block</span> = (<span class="ruby-identifier">subsequent_line</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>)
      <span class="ruby-identifier">content_adjacent</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">subsequent_line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">continuation_connects_first_block</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-identifier">content_adjacent</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># only relevant for :dlist</span>
    <span class="ruby-identifier">options</span> = {<span class="ruby-value">:text</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">has_text</span>}

    <span class="ruby-keyword">while</span> <span class="ruby-identifier">list_item_reader</span>.<span class="ruby-identifier">has_lines?</span>
      <span class="ruby-identifier">new_block</span> = <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">list_item_reader</span>, <span class="ruby-identifier">list_block</span>, {}, <span class="ruby-identifier">options</span>)
      <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_block</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">new_block</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">fold_first</span>(<span class="ruby-identifier">continuation_connects_first_block</span>, <span class="ruby-identifier">content_adjacent</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dlist</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">text?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">blocks?</span>
      <span class="ruby-identifier">list_item</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
    [<span class="ruby-identifier">list_term</span>, <span class="ruby-identifier">list_item</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">list_item</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_list_item-source -->
          
        </div>

        

        
      </div><!-- next_list_item-method -->

    
      <div id="method-c-next_outline_list" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_outline_list</span><span
            class="method-args">(reader, list_type, parent)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse and construct an outline list <a href="Block.html">Block</a> from the
current position of the <a href="Reader.html">Reader</a></p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>The <a href="Reader.html">Reader</a> from which to retrieve the outline
list</p>
</dd><dt>list_type
<dd>
<p>A Symbol representing the list type (:olist for ordered, :ulist for
unordered)</p>
</dd><dt>parent
<dd>
<p>The parent <a href="Block.html">Block</a> to which this outline list
belongs</p>
</dd></dl>

<p>Returns the <a href="Block.html">Block</a> encapsulating the parsed outline
(unordered or ordered) list</p>
          

          
          <div class="method-source-code" id="next_outline_list-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 602</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_outline_list</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">parent</span>)
  <span class="ruby-identifier">list_block</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">list_type</span>)
  <span class="ruby-identifier">items</span> = []
  <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">buffer</span> = <span class="ruby-identifier">items</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_type</span>
    <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> = <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-constant">Asciidoctor</span>.<span class="ruby-identifier">debug</span> { <span class="ruby-node">&quot;Created #{list_type} block: #{list_block}&quot;</span> }

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-identifier">list_type</span>]))

    <span class="ruby-identifier">marker</span> = <span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>])

    <span class="ruby-comment"># if we are moving to the next item, and the marker is different</span>
    <span class="ruby-comment"># determine if we are moving up or down in nesting</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">marker</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
      <span class="ruby-comment"># assume list is nested by default, but then check to see if we are</span>
      <span class="ruby-comment"># popping out of a nested list by matching an ancestor's list marker</span>
      <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">p</span> = <span class="ruby-identifier">parent</span>
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_type</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">marker</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">marker</span>
          <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">p</span>.<span class="ruby-identifier">level</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">p</span> = <span class="ruby-identifier">p</span>.<span class="ruby-identifier">parent</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">this_item_level</span> = <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-identifier">list_item</span> = <span class="ruby-identifier">next_list_item</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>, <span class="ruby-identifier">match</span>)
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-comment"># leave this block</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">this_item_level</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">list_block</span>.<span class="ruby-identifier">level</span>
      <span class="ruby-comment"># If this next list level is down one from the</span>
      <span class="ruby-comment"># current Block's, append it to content of the current list item</span>
      <span class="ruby-identifier">items</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">blocks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">next_block</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">list_block</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">items</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">list_item</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">list_item</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">list_item</span> = <span class="ruby-keyword">nil</span>

    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">list_block</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_outline_list-source -->
          
        </div>

        

        
      </div><!-- next_outline_list-method -->

    
      <div id="method-c-next_table" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">next_table</span><span
            class="method-args">(table_reader, parent, attributes)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse the table contained in the provided <a href="Reader.html">Reader</a></p>
<dl class="rdoc-list note-list"><dt>table_reader
<dd>
<p>a <a href="Reader.html">Reader</a> containing the source lines of an
AsciiDoc table</p>
</dd><dt>parent
<dd>
<p>the parent <a href="Block.html">Block</a> of this <a
href="Table.html">Asciidoctor::Table</a></p>
</dd><dt>attributes
<dd>
<p>attributes captured from above this <a href="Block.html">Block</a></p>
</dd></dl>

<p>returns an instance of <a href="Table.html">Asciidoctor::Table</a> parsed
from the provided reader</p>
          

          
          <div class="method-source-code" id="next_table-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1409</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">next_table</span>(<span class="ruby-identifier">table_reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-identifier">table</span> = <span class="ruby-constant">Table</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span> <span class="ruby-string">'cols'</span>
    <span class="ruby-identifier">table</span>.<span class="ruby-identifier">create_columns</span>(<span class="ruby-identifier">parse_col_specs</span>(<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'cols'</span>]))
    <span class="ruby-identifier">explicit_col_specs</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">explicit_col_specs</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">skip_blank_lines</span>

  <span class="ruby-identifier">parser_ctx</span> = <span class="ruby-constant">Asciidoctor</span><span class="ruby-operator">::</span><span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ParserContext</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">table</span>, <span class="ruby-identifier">attributes</span>)
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">has_lines?</span>
    <span class="ruby-identifier">line</span> = <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">get_line</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">starts_with_delimiter?</span> <span class="ruby-identifier">line</span>
        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">line</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
        <span class="ruby-comment"># push an empty cell spec if boundary at start of line</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_open_cell</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">next_cell_spec</span>, <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">line</span>, <span class="ruby-value">:start</span>)
        <span class="ruby-comment"># if the cell spec is not null, then we're at a cell boundary</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">next_cell_spec</span>.<span class="ruby-identifier">nil?</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_open_cell</span> <span class="ruby-identifier">next_cell_spec</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-comment"># QUESTION do we not advance to next line? if so, when</span>
          <span class="ruby-comment"># will we if we came into this block?</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">while</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line</span>.<span class="ruby-identifier">empty?</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">match_delimiter</span>(<span class="ruby-identifier">line</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer_has_unclosed_quotes?</span>(<span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>)
            <span class="ruby-comment"># throw it back, it's too small</span>
            <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">skip_matched_delimiter</span>(<span class="ruby-identifier">m</span>)
            <span class="ruby-keyword">next</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>.<span class="ruby-identifier">end_with?</span> <span class="ruby-string">'\'</span>
            <span class="ruby-identifier">line</span> = <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">skip_matched_delimiter</span>(<span class="ruby-identifier">m</span>, <span class="ruby-keyword">true</span>)
            <span class="ruby-keyword">next</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span>
          <span class="ruby-identifier">next_cell_spec</span>, <span class="ruby-identifier">cell_text</span> = <span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>, <span class="ruby-value">:end</span>)
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">push_cell_spec</span> <span class="ruby-identifier">next_cell_spec</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">cell_text</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">m</span>.<span class="ruby-identifier">post_match</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># no other delimiters to see here</span>
        <span class="ruby-comment"># suck up this line into the buffer and move on</span>
        <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">line</span>
        <span class="ruby-comment"># QUESTION make this an option? (unwrap-option?)</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer</span>.<span class="ruby-identifier">rstrip!</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-string">' '</span>)
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">line</span> = <span class="ruby-string">''</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'psv'</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">format</span> <span class="ruby-operator">==</span> <span class="ruby-string">'csv'</span> <span class="ruby-operator">&amp;&amp;</span>
            <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">buffer_has_unclosed_quotes?</span>)
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">keep_cell_open</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span> <span class="ruby-keyword">true</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">skip_blank_lines</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">cell_open?</span>

    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">table_reader</span>.<span class="ruby-identifier">has_lines?</span>
      <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">close_cell</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">attributes</span>[<span class="ruby-string">'colcount'</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">col_count</span>

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">explicit_col_specs</span>
    <span class="ruby-comment"># TODO further encapsulate this logic (into table perhaps?)</span>
    <span class="ruby-identifier">even_width</span> = (<span class="ruby-value">100.0</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">parser_ctx</span>.<span class="ruby-identifier">col_count</span>).<span class="ruby-identifier">floor</span>
    <span class="ruby-identifier">table</span>.<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">assign_width</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">even_width</span>) }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">table</span>.<span class="ruby-identifier">partition_header_footer</span> <span class="ruby-identifier">attributes</span>

  <span class="ruby-identifier">table</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- next_table-source -->
          
        </div>

        

        
      </div><!-- next_table-method -->

    
      <div id="method-c-parse_block_metadata_line" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_block_metadata_line</span><span
            class="method-args">(reader, parent, attributes, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse the next line if it contains metadata for the following block</p>

<p>This method handles lines with the following content:</p>

<p>* line or block comment * anchor * attribute list * block title</p>

<p>Any attributes found will be inserted into the attributes argument. If the
line contains block metadata, the method returns true, otherwise false.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source reader</p>
</dd><dt>parent
<dd>
<p>the parent of the current line</p>
</dd><dt>attributes
<dd>
<p>a Hash of attributes in which any metadata found will be stored</p>
</dd><dt>options
<dd>
<p>a Hash of options to control processing: (default: {}) *  :text indicates
that lexer is only looking for text content and thus the block title should
not be captured</p>
</dd></dl>

<p>returns true if the line contains metadata, otherwise false</p>
          

          
          <div class="method-source-code" id="parse_block_metadata_line-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1247</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">has_lines?</span>
  <span class="ruby-identifier">next_line</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:comment</span>])
    <span class="ruby-comment"># do nothing, we'll skip it</span>
  <span class="ruby-comment"># QUESTION should we parse block comments here instead of next_block?</span>
  <span class="ruby-comment"># disable until we can agree what the current line is coming in</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:comment_blk</span>])
    <span class="ruby-identifier">terminator</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">grab_lines_until</span>(<span class="ruby-value">:skip_first_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:preserve_last_line</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:terminator</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">terminator</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor</span>])
    <span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>)
    <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'id'</span>] = <span class="ruby-identifier">id</span>
    <span class="ruby-comment"># AsciiDoc always use [id] as the reftext in HTML output,</span>
    <span class="ruby-comment"># but I'd like to do better in Asciidoctor</span>
    <span class="ruby-comment">#parent.document.register(:ids, id)</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">reftext</span>
      <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'reftext'</span>] = <span class="ruby-identifier">reftext</span>
      <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">register</span>(<span class="ruby-value">:ids</span>, [<span class="ruby-identifier">id</span>, <span class="ruby-identifier">reftext</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:blk_attr_list</span>])
    <span class="ruby-constant">AttributeList</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">sub_attributes</span>(<span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]), <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">document</span>).<span class="ruby-identifier">parse_into</span>(<span class="ruby-identifier">attributes</span>)
  <span class="ruby-comment"># NOTE title doesn't apply to section, but we need to stash it for the first block</span>
  <span class="ruby-comment"># TODO need test for this getting passed on to first block after section if found above section</span>
  <span class="ruby-comment"># TODO should issue an error if this is found above the document title</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-value">:text</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">match</span> = <span class="ruby-identifier">next_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:blk_title</span>]))
    <span class="ruby-identifier">attributes</span>[<span class="ruby-string">'title'</span>] = <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_block_metadata_line-source -->
          
        </div>

        

        
      </div><!-- parse_block_metadata_line-method -->

    
      <div id="method-c-parse_block_metadata_lines" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_block_metadata_lines</span><span
            class="method-args">(reader, parent, attributes = {}, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse lines of metadata until a line of metadata is not found.</p>

<p>This method processes sequential lines containing block metadata, ignoring
blank lines and comments.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source reader</p>
</dd><dt>parent
<dd>
<p>the parent to which the lines belong</p>
</dd><dt>attributes
<dd>
<p>a Hash of attributes in which any metadata found will be stored (default:
{})</p>
</dd><dt>options
<dd>
<p>a Hash of options to control processing: (default: {}) *  :text indicates
that lexer is only looking for text content and thus the block title should
not be captured</p>
</dd></dl>

<p>returns the Hash of attributes including any metadata found</p>
          

          
          <div class="method-source-code" id="parse_block_metadata_lines-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1219</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_block_metadata_lines</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span> = {}, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">parse_block_metadata_line</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">options</span>)
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">next_line</span>
    <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">skip_blank_lines</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">attributes</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_block_metadata_lines-source -->
          
        </div>

        

        
      </div><!-- parse_block_metadata_lines-method -->

    
      <div id="method-c-parse_cell_spec" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_cell_spec</span><span
            class="method-args">(line, pos = :start)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse the cell specs for the current cell.</p>

<p>The cell specs dictate the cell’s alignments, styles or filters, colspan,
rowspan and/or repeating content.</p>

<p>returns the Hash of attributes that indicate how to layout and style this
cell in the table.</p>
          

          
          <div class="method-source-code" id="parse_cell_spec-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1567</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_cell_spec</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">pos</span> = <span class="ruby-value">:start</span>)
  <span class="ruby-comment"># the default for the end pos it {} since we</span>
  <span class="ruby-comment"># know we're at a delimiter; when the pos</span>
  <span class="ruby-comment"># is start, we *may* be at a delimiter and</span>
  <span class="ruby-comment"># nil indicates we're not</span>
  <span class="ruby-identifier">spec</span> = (<span class="ruby-identifier">pos</span> <span class="ruby-operator">==</span> <span class="ruby-value">:end</span> <span class="ruby-operator">?</span> {} <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">line</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:table_cellspec</span>][<span class="ruby-identifier">pos</span>]) 
    <span class="ruby-identifier">spec</span> = {}
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">line</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">rest</span> = (<span class="ruby-identifier">pos</span> <span class="ruby-operator">==</span> <span class="ruby-value">:start</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">post_match</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">pre_match</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>]
      <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
      <span class="ruby-identifier">colspec</span> = <span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'+'</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'colspan'</span>] = <span class="ruby-identifier">colspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">colspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'rowspan'</span>] = <span class="ruby-identifier">rowspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">rowspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">==</span> <span class="ruby-string">'*'</span>
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'repeatcol'</span>] = <span class="ruby-identifier">colspec</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">colspec</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>]
      <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">colspec</span>)
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'halign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>][<span class="ruby-identifier">colspec</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">rowspec</span>)
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'valign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>][<span class="ruby-identifier">rowspec</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>])
      <span class="ruby-identifier">spec</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>[<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>]]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span> 

  [<span class="ruby-identifier">spec</span>, <span class="ruby-identifier">rest</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_cell_spec-source -->
          
        </div>

        

        
      </div><!-- parse_cell_spec-method -->

    
      <div id="method-c-parse_col_specs" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_col_specs</span><span
            class="method-args">(records)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse the column specs for this table.</p>

<p>The column specs dictate the number of columns, relative width of columns,
default alignments for cells in each column, and/or default styles or
filters applied to the cells in  the column.</p>

<p>Every column spec is guaranteed to have a width</p>

<p>returns a Hash of attributes that specify how to format and layout the
cells in the table.</p>
          

          
          <div class="method-source-code" id="parse_col_specs-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1516</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_col_specs</span>(<span class="ruby-identifier">records</span>)
  <span class="ruby-identifier">specs</span> = []

  <span class="ruby-comment"># check for deprecated syntax</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">records</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:digits</span>])
    <span class="ruby-value">1</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">to_i</span>) {
      <span class="ruby-identifier">specs</span> <span class="ruby-operator">&lt;&lt;</span> {<span class="ruby-string">'width'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">specs</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">records</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">','</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">record</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># TODO might want to use scan rather than this mega-regexp</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span> = <span class="ruby-identifier">record</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:table_colspec</span>])
      <span class="ruby-identifier">spec</span> = {}
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>]
        <span class="ruby-comment"># make this an operation</span>
        <span class="ruby-identifier">colspec</span>, <span class="ruby-identifier">rowspec</span> = <span class="ruby-identifier">m</span>[<span class="ruby-value">2</span>].<span class="ruby-identifier">split</span> <span class="ruby-string">'.'</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">colspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">colspec</span>)
          <span class="ruby-identifier">spec</span>[<span class="ruby-string">'halign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:h</span>][<span class="ruby-identifier">colspec</span>]
        <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">rowspec</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">rowspec</span>)
          <span class="ruby-identifier">spec</span>[<span class="ruby-string">'valign'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">ALIGNMENTS</span>[<span class="ruby-value">:v</span>][<span class="ruby-identifier">rowspec</span>]
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-comment"># TODO support percentage width</span>
      <span class="ruby-identifier">spec</span>[<span class="ruby-string">'width'</span>] = <span class="ruby-operator">!</span><span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">3</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span>

      <span class="ruby-comment"># make this an operation</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>])
        <span class="ruby-identifier">spec</span>[<span class="ruby-string">'style'</span>] = <span class="ruby-constant">Table</span><span class="ruby-operator">::</span><span class="ruby-constant">TEXT_STYLES</span>[<span class="ruby-identifier">m</span>[<span class="ruby-value">4</span>]]
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">repeat</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span>

      <span class="ruby-value">1</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">repeat</span>) {
        <span class="ruby-identifier">specs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">spec</span>.<span class="ruby-identifier">dup</span>
      }
    <span class="ruby-keyword">end</span>
  }
  <span class="ruby-identifier">specs</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_col_specs-source -->
          
        </div>

        

        
      </div><!-- parse_col_specs-method -->

    
      <div id="method-c-parse_section_title" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">parse_section_title</span><span
            class="method-args">(reader)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Parse the section title from the current position of the reader</p>

<p>Parse a single or double-line section title. After this method is called,
the <a href="Reader.html">Reader</a> will be positioned at the line after
the section title.</p>
<dl class="rdoc-list note-list"><dt>reader
<dd>
<p>the source reader, positioned at a section title</p>
</dd></dl>

<h3 id="method-c-parse_section_title-label-Examples">Examples</h3>

<pre class="ruby"><span class="ruby-identifier">reader</span>.<span class="ruby-identifier">lines</span>
<span class="ruby-comment"># =&gt; [&quot;Foo\n&quot;, &quot;~~~\n&quot;]</span>

<span class="ruby-identifier">title</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">id</span>, <span class="ruby-identifier">single</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>)

<span class="ruby-identifier">title</span>
<span class="ruby-comment"># =&gt; &quot;Foo&quot;</span>
<span class="ruby-identifier">level</span>
<span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">id</span>
<span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">single</span>
<span class="ruby-comment"># =&gt; false</span>

<span class="ruby-identifier">line1</span>
<span class="ruby-comment"># =&gt; &quot;==== Foo\n&quot;</span>

<span class="ruby-identifier">title</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">id</span>, <span class="ruby-identifier">single</span> = <span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>)

<span class="ruby-identifier">title</span>
<span class="ruby-comment"># =&gt; &quot;Foo&quot;</span>
<span class="ruby-identifier">level</span>
<span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">id</span>
<span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">single</span>
<span class="ruby-comment"># =&gt; true</span>
</pre>

<p>returns an Array of [String, Integer, String, Boolean], representing the
id, title, level and line count of the <a href="Section.html">Section</a>,
or nil.</p>
          

          
          <div class="method-source-code" id="parse_section_title-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1108</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">parse_section_title</span>(<span class="ruby-identifier">reader</span>)
  <span class="ruby-identifier">line1</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
  <span class="ruby-identifier">sect_id</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">sect_title</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">sect_level</span> = <span class="ruby-value">-1</span>
  <span class="ruby-identifier">single_line</span> = <span class="ruby-keyword">true</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_title</span>])
    <span class="ruby-identifier">sect_id</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">3</span>]
    <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">match</span>[<span class="ruby-value">2</span>]
    <span class="ruby-identifier">sect_level</span> = <span class="ruby-identifier">single_line_section_level</span> <span class="ruby-identifier">match</span>[<span class="ruby-value">1</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">line2</span> = <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">peek_line</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line2</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">name_match</span> = <span class="ruby-identifier">line1</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_name</span>])) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:section_underline</span>]) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-comment"># chomp so that a (non-visible) endline does not impact calculation</span>
      (<span class="ruby-identifier">line1</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">line2</span>.<span class="ruby-identifier">chomp</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">abs</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">anchor_match</span> = <span class="ruby-identifier">name_match</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">match</span>(<span class="ruby-constant">REGEXP</span>[<span class="ruby-value">:anchor_embedded</span>]) 
        <span class="ruby-identifier">sect_id</span> = <span class="ruby-identifier">anchor_match</span>[<span class="ruby-value">2</span>]
        <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">anchor_match</span>[<span class="ruby-value">1</span>]
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">sect_title</span> = <span class="ruby-identifier">name_match</span>[<span class="ruby-value">1</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">sect_level</span> = <span class="ruby-identifier">section_level</span> <span class="ruby-identifier">line2</span>
      <span class="ruby-identifier">single_line</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-identifier">reader</span>.<span class="ruby-identifier">get_line</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> [<span class="ruby-identifier">sect_id</span>, <span class="ruby-identifier">sect_title</span>, <span class="ruby-identifier">sect_level</span>, <span class="ruby-identifier">single_line</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- parse_section_title-source -->
          
        </div>

        

        
      </div><!-- parse_section_title-method -->

    
      <div id="method-c-resolve_list_marker" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">resolve_list_marker</span><span
            class="method-args">(list_type, marker, ordinal = 0, validate = false)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Resolve the 0-index marker for this list item</p>

<p>For ordered lists, match the marker used for this list item against the
known list markers and determine which marker is the first (0-index) marker
in its number series.</p>

<p>For callout lists, return &lt;1&gt;.</p>

<p>For bulleted lists, return the marker as passed to this method.</p>
<dl class="rdoc-list note-list"><dt>list_type
<dd>
<p>The Symbol context of the list</p>
</dd><dt>marker
<dd>
<p>The String marker for this list item</p>
</dd><dt>ordinal
<dd>
<p>The position of this list item in the list</p>
</dd><dt>validate
<dd>
<p>Whether to validate the value of the marker</p>
</dd></dl>

<p>Returns the String 0-index marker for this list item</p>
          

          
          <div class="method-source-code" id="resolve_list_marker-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1297</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">resolve_list_marker</span>(<span class="ruby-identifier">list_type</span>, <span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">validate</span> = <span class="ruby-keyword">false</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:olist</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">marker</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">'.'</span>)
    <span class="ruby-identifier">resolve_ordered_list_marker</span>(<span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span>, <span class="ruby-identifier">validate</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">list_type</span> <span class="ruby-operator">==</span> <span class="ruby-value">:colist</span>
    <span class="ruby-string">'&lt;1&gt;'</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">marker</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- resolve_list_marker-source -->
          
        </div>

        

        
      </div><!-- resolve_list_marker-method -->

    
      <div id="method-c-resolve_ordered_list_marker" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">resolve_ordered_list_marker</span><span
            class="method-args">(marker, ordinal = 0, validate = false)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Resolve the 0-index marker for this ordered list item</p>

<p>Match the marker used for this ordered list item against the known ordered
list markers and determine which marker is the first (0-index) marker in
its number series.</p>

<p>The purpose of this method is to normalize the implicit numbered markers so
that they can be compared against other list items.</p>
<dl class="rdoc-list note-list"><dt>marker
<dd>
<p>The marker used for this list item</p>
</dd><dt>ordinal
<dd>
<p>The 0-based index of the list item (default: 0)</p>
</dd><dt>validate
<dd>
<p>Perform validation that the marker provided is the proper marker in the
sequence (default: false)</p>
</dd></dl>

<h3 id="method-c-resolve_ordered_list_marker-label-Examples">Examples</h3>

<pre class="ruby"><span class="ruby-identifier">marker</span> = <span class="ruby-string">'B.'</span>
<span class="ruby-constant">Lexer</span><span class="ruby-operator">::</span><span class="ruby-identifier">resolve_ordered_list_marker</span>(<span class="ruby-identifier">marker</span>, <span class="ruby-value">1</span>, <span class="ruby-keyword">true</span>)
<span class="ruby-comment"># =&gt; 'A.'</span>
</pre>

<p>Returns the String of the first marker in this number series</p>
          

          
          <div class="method-source-code" id="resolve_ordered_list_marker-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1328</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">resolve_ordered_list_marker</span>(<span class="ruby-identifier">marker</span>, <span class="ruby-identifier">ordinal</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">validate</span> = <span class="ruby-keyword">false</span>)
  <span class="ruby-identifier">number_style</span> = <span class="ruby-constant">ORDERED_LIST_STYLES</span>.<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">ORDERED_LIST_MARKER_PATTERNS</span>[<span class="ruby-identifier">s</span>]) }
  <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">actual</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">number_style</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:arabic</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">to_i</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'1.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:loweralpha</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = (<span class="ruby-string">'a'</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">ord</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ordinal</span>).<span class="ruby-identifier">chr</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">'.'</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'a.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:upperalpha</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-identifier">expected</span> = (<span class="ruby-string">'A'</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">ord</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ordinal</span>).<span class="ruby-identifier">chr</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">'.'</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'A.'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:lowerroman</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-comment"># TODO report this in roman numerals; see https://github.com/jamesshipton/roman-numeral/blob/master/lib/roman_numeral.rb</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">')'</span>))
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'i)'</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:upperroman</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span>
        <span class="ruby-comment"># TODO report this in roman numerals; see https://github.com/jamesshipton/roman-numeral/blob/master/lib/roman_numeral.rb</span>
        <span class="ruby-identifier">expected</span> = <span class="ruby-identifier">ordinal</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">actual</span> = <span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">marker</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">')'</span>))
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">marker</span> = <span class="ruby-string">'I)'</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">validate</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">expected</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">actual</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;asciidoctor: WARNING: list item index: expected #{expected}, got #{actual}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">marker</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- resolve_ordered_list_marker-source -->
          
        </div>

        

        
      </div><!-- resolve_ordered_list_marker-method -->

    
      <div id="method-c-roman_numeral_to_int" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">roman_numeral_to_int</span><span
            class="method-args">(value)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Converts a Roman numeral to an integer value.</p>
<dl class="rdoc-list note-list"><dt>value
<dd>
<p>The String Roman numeral to convert</p>
</dd></dl>

<p>Returns the Integer for this Roman numeral</p>
          

          
          <div class="method-source-code" id="roman_numeral_to_int-source">
            <pre><span class="ruby-comment"># File lib/asciidoctor/lexer.rb, line 1614</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">roman_numeral_to_int</span>(<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">value</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">downcase</span>
  <span class="ruby-identifier">digits</span> = { <span class="ruby-string">'i'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-string">'v'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">5</span>, <span class="ruby-string">'x'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">10</span> }
  <span class="ruby-identifier">result</span> = <span class="ruby-value">0</span>
  
  (<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-identifier">value</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">digit</span> = <span class="ruby-identifier">digits</span>[<span class="ruby-identifier">value</span>[<span class="ruby-identifier">i</span><span class="ruby-operator">..</span><span class="ruby-identifier">i</span>]]
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">digits</span>[<span class="ruby-identifier">value</span>[<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>]] <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">digit</span>
      <span class="ruby-identifier">result</span> <span class="ruby-operator">-=</span> <span class="ruby-identifier">digit</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">result</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">digit</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- roman_numeral_to_int-source -->
          
        </div>

        

        
      </div><!-- roman_numeral_to_int-method -->

    
    </section><!-- public-class-method-details -->
  
  </section><!-- Internal -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

